<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Samantha - Voice Math Assistant</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        button { margin: 10px; padding: 10px 20px; }
        #status { color: red; }
    </style>
</head>
<body>
    <h1>Samantha</h1>
    <p>Your friendly voice math assistant</p>

    <div>
        <label>Mode:</label>
        <select id="modeSelect">
            <option value="manual">Manual (Push-to-Talk / Text)</option>
            <option value="continuous">Continuous Call</option>
        </select>
    </div>

    <div id="manualMode" style="display: block;">
        <button id="startRecording">Start Recording</button>
        <button id="stopRecording" style="display: none;">Stop Recording</button>
        <p id="manualStatus">Press "Start Recording" to begin, speak, then "Stop Recording" to send.</p>
    </div>

    <div id="continuousMode" style="display: none;">
        <button id="startCall">Start Call</button>
        <button id="endCall" style="display: none;">End Call</button>
        <p id="callStatus">Press "Start Call" to begin continuous conversation.</p>
    </div>

    <p id="status"></p>

    <script>
        // Mode switcher
        const modeSelect = document.getElementById('modeSelect');
        const manualMode = document.getElementById('manualMode');
        const continuousMode = document.getElementById('continuousMode');
        const status = document.getElementById('status');

        modeSelect.addEventListener('change', (e) => {
            if (e.target.value === 'manual') {
                manualMode.style.display = 'block';
                continuousMode.style.display = 'none';
            } else {
                manualMode.style.display = 'none';
                continuousMode.style.display = 'block';
            }
        });

        // Manual Mode (Push-to-Talk)
        let mediaRecorderManual;
        let audioChunksManual = [];
        const startRecordingBtn = document.getElementById('startRecording');
        const stopRecordingBtn = document.getElementById('stopRecording');
        const manualStatus = document.getElementById('manualStatus');

        startRecordingBtn.addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                console.log('Microphone access granted');
                mediaRecorderManual = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
                mediaRecorderManual.start();
                startRecordingBtn.style.display = 'none';
                stopRecordingBtn.style.display = 'block';
                audioChunksManual = [];
                mediaRecorderManual.addEventListener('dataavailable', event => {
                    console.log('Audio chunk received:', event.data.size, 'bytes');
                    audioChunksManual.push(event.data);
                });
                mediaRecorderManual.onerror = (event) => {
                    console.error('MediaRecorder error:', event.error);
                    manualStatus.textContent = 'Recording error. Try again.';
                };
                manualStatus.textContent = 'Recording... Speak now.';
            } catch (err) {
                console.error('Microphone access error:', err);
                manualStatus.textContent = 'Could not access microphone. Check permissions.';
                status.textContent = 'Mic error: ' + err.message;
            }
        });

        stopRecordingBtn.addEventListener('click', () => {
            mediaRecorderManual.stop();
            startRecordingBtn.style.display = 'block';
            stopRecordingBtn.style.display = 'none';
            manualStatus.textContent = 'Processing...';
            mediaRecorderManual.addEventListener('stop', () => {
                const audioBlob = new Blob(audioChunksManual, { type: 'audio/webm' });
                console.log('Recording stopped, blob size:', audioBlob.size);
                if (audioBlob.size < 500) {
                    manualStatus.textContent = 'Recording too short or empty. Try again.';
                    status.textContent = 'Error: Recording too short (<500 bytes)';
                    return;
                }
                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.webm');
                fetch('/voice-chat-legacy', {
                    method: 'POST',
                    body: formData
                }).then(response => {
                    if (response.ok) {
                        manualStatus.textContent = 'Response received. Playing audio...';
                        response.blob().then(blob => {
                            const url = URL.createObjectURL(blob);
                            new Audio(url).play();
                        });
                    } else {
                        manualStatus.textContent = 'Upload failed. Try again.';
                        status.textContent = 'Error: Upload failed';
                    }
                }).catch(err => {
                    console.error('Fetch error:', err);
                    manualStatus.textContent = 'Error sending recording.';
                    status.textContent = 'Error: ' + err.message;
                });
            });
        });

        // Continuous Mode (WebSocket)
        let ws;
        let mediaRecorderContinuous;
        let streamContinuous;
        const startCallBtn = document.getElementById('startCall');
        const endCallBtn = document.getElementById('endCall');
        const callStatus = document.getElementById('callStatus');

        startCallBtn.addEventListener('click', async () => {
            try {
                streamContinuous = await navigator.mediaDevices.getUserMedia({ audio: true });
                console.log('Microphone access granted for continuous mode');
                status.textContent = '';
                ws = new WebSocket('ws://localhost:5000/voice');  // Adjust if deployed

                ws.onopen = () => {
                    console.log('WebSocket connected');
                    callStatus.textContent = 'Connected. Speak freely...';
                    startCallBtn.style.display = 'none';
                    endCallBtn.style.display = 'block';
                    try {
                        mediaRecorderContinuous = new MediaRecorder(streamContinuous, { 
                            mimeType: 'audio/webm;codecs=opus',
                            audioBitsPerSecond: 16000
                        });
                        mediaRecorderContinuous.start(250);  // Send chunks every 250ms
                        mediaRecorderContinuous.ondataavailable = event => {
                            if (event.data.size > 0 && ws.readyState === WebSocket.OPEN) {
                                console.log('Sending audio chunk:', event.data.size, 'bytes');
                                ws.send(event.data);  // Send binary blob
                            } else {
                                console.warn('Empty chunk or WS closed, skipping');
                            }
                        };
                        mediaRecorderContinuous.onerror = (event) => {
                            console.error('MediaRecorder error:', event.error);
                            callStatus.textContent = 'Recording error. Try again.';
                            status.textContent = 'MediaRecorder error: ' + event.error.message;
                        };
                    } catch (err) {
                        console.error('MediaRecorder setup error:', err);
                        callStatus.textContent = 'Failed to start recording.';
                        status.textContent = 'MediaRecorder error: ' + err.message;
                        ws.close();
                    }
                };

                ws.onmessage = event => {
                    if (event.data instanceof Blob) {
                        console.log('Received audio response:', event.data.size, 'bytes');
                        const url = URL.createObjectURL(event.data);
                        new Audio(url).play();
                    } else {
                        try {
                            const msg = JSON.parse(event.data);
                            console.log('Received JSON:', msg);
                            if (msg.type === 'user_transcript') {
                                console.log('User said:', msg.data);
                            } else if (msg.type === 'bot_response_text') {
                                console.log('Bot response:', msg.data);
                            } else if (msg.type === 'error') {
                                callStatus.textContent = 'Error: ' + msg.data;
                                status.textContent = 'Server error: ' + msg.data;
                            } else if (msg.type === 'connected') {
                                console.log('Server ready:', msg.data);
                            }
                        } catch (e) {
                            console.log('Received non-JSON:', event.data);
                        }
                    }
                };

                ws.onclose = event => {
                    console.log(`WebSocket closed. Code: ${event.code}, Reason: ${event.reason}`);
                    callStatus.textContent = 'Call ended.';
                    status.textContent = `Closed with code ${event.code}: ${event.reason || 'No reason provided'}`;
                    if (mediaRecorderContinuous) mediaRecorderContinuous.stop();
                    if (streamContinuous) streamContinuous.getTracks().forEach(track => track.stop());
                    startCallBtn.style.display = 'block';
                    endCallBtn.style.display = 'none';
                };

                ws.onerror = err => {
                    console.error('WebSocket error:', err);
                    callStatus.textContent = 'WebSocket error. Try again.';
                    status.textContent = 'WebSocket error';
                };
            } catch (err) {
                console.error('Mic/WS setup error:', err);
                callStatus.textContent = 'Failed to start call. Check mic permissions.';
                status.textContent = 'Error: ' + err.message;
            }
        });

        endCallBtn.addEventListener('click', () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close(1000, 'User ended call');
            }
            callStatus.textContent = 'Call ended.';
            status.textContent = 'Call ended by user';
            if (mediaRecorderContinuous) mediaRecorderContinuous.stop();
            if (streamContinuous) streamContinuous.getTracks().forEach(track => track.stop());
            startCallBtn.style.display = 'block';
            endCallBtn.style.display = 'none';
        });
    </script>
</body>
</html>